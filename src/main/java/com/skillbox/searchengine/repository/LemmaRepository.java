package com.skillbox.searchengine.repository;

import com.skillbox.searchengine.entity.BatchSavable;
import com.skillbox.searchengine.entity.Lemma;
import com.skillbox.searchengine.entity.Site;
import com.skillbox.searchengine.utils.LemmaCounter;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.query.Query;
import org.jsoup.nodes.Document;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class LemmaRepository {
    private static final SessionFactory sessionFactory = CustomRepository.getSessionFactory();
    private static final int BATCH_SIZE = 30;

    private LemmaRepository(){}

    public static Lemma get(String lemmaStr, Integer siteId) {
        Lemma result = null;
        Transaction transaction = null;
        Session session = sessionFactory.openSession();

        try {
            transaction = session.beginTransaction();
            Query<Lemma> query = session.createQuery("from Lemma l where l.lemma = :lemma and l.siteId = :siteId", Lemma.class);
            query.setParameter("lemma", lemmaStr);
            query.setParameter("siteId", siteId);
            result = query.uniqueResult();
            transaction.commit();
        } catch (Exception e) {
            if (transaction != null) {
                transaction.rollback();
            }
            e.printStackTrace();
        } finally {
            session.close();
        }

        return result;
    }

    /**
     * Saves map of lemma-rank into the database.
     * @param lemmaRankMap, generated by LemmaCounter.generateMap method.
     * @return map containing ids of saved lemmas and their ranks
     */
    //Inserts lemmas in batches into the database, returns their respective ids to generate a (lemma_id, rank) map
    //todo rewrite findId method to include site_id as well
    private static Map<Integer, Double> saveLemmaRankMap(Map<Lemma, Double> lemmaRankMap, Site site) {
        Map<Integer, Double> idRankMap = new HashMap<>();
        List<Lemma> lemmas = new ArrayList<>(lemmaRankMap.keySet());
        lemmas.forEach(lemma -> lemma.setSiteId(site.getId()));

        batchInsert(lemmas);
        lemmas.forEach(lemma ->
                idRankMap.put(findId(lemma), lemmaRankMap.get(lemma)));
        return idRankMap;
    }

    /**
     * Extracts lemmas from Jsoup document and saves them in the database.
     * @param document - Jsoup document.
     * @return map, containing id and rank of saved lemmas.
     */
    public static synchronized Map<Integer, Double> saveLemmas(Document document, Site site) {
        Map<Lemma, Double> lemmaRankMap = LemmaCounter.generateMap(document, site);
        return saveLemmaRankMap(lemmaRankMap, site);
    }

    //@param lemma - quasi-lemma, containing only String lemma value and siteId
    private static Integer findId(Lemma lemma) {
        Lemma repoLemma = null;
        Transaction transaction = null;
        Session session = sessionFactory.openSession();
        try {
            transaction = session.beginTransaction();
            Query<Lemma> query = session.createQuery("from Lemma l where l.lemma = :lemma and l.siteId = :siteId", Lemma.class);
            query.setParameter("lemma", lemma.getLemma());
            query.setParameter("siteId", lemma.getSiteId());
            repoLemma = query.uniqueResult();
            transaction.commit();
        } catch (Exception e) {
            if (transaction != null) {
                transaction.rollback();
            }
            e.printStackTrace();
        } finally {
            session.close();
        }
        return repoLemma == null ? null : repoLemma.getId();
    }

    //change to private after testing
    public static <T extends BatchSavable> void batchInsert(List<T> list) {
        if (list.size() > BATCH_SIZE) {
            List<List<T>> batches = splitList(list);
            batches.forEach(LemmaRepository::saveBatch);
        }
        else {
            saveBatch(list);
        }
    }

    private static <T extends BatchSavable> void saveBatch(List<T> batch) {
        StringBuilder sqlBuilder = new StringBuilder("INSERT INTO ");
        sqlBuilder.append(batch.get(0).getSqlParams());

        for (T entry : batch) {
            sqlBuilder.append(entry.getFieldsAsSQL()).append(',');
        }
        sqlBuilder.deleteCharAt(sqlBuilder.length() - 1);
        sqlBuilder.append(batch.get(0).getEnding());

        Session session = sessionFactory.openSession();
        Transaction transaction = null;
        try {
            transaction = session.beginTransaction();
            session.createSQLQuery(sqlBuilder.toString()).executeUpdate();
            transaction.commit();
        } catch (Exception e) {
            if (transaction != null) {
                transaction.rollback();
            }
            e.printStackTrace();
        } finally {
            session.close();
        }
    }

    private static <T extends BatchSavable> List<List<T>> splitList(List<T> list) {
        List<List<T>> result = new ArrayList<>();
        if (list.size() > BATCH_SIZE) {
            int count = list.size() % BATCH_SIZE == 0 ?
                    list.size() / BATCH_SIZE :
                    list.size() / BATCH_SIZE + 1;
            for (int i = 0; i < count; i++) {
                int start = i * BATCH_SIZE;
                int end = Math.min(start + BATCH_SIZE, list.size());
                result.add(list.subList(start, end));
            }
        } else {
            result.add(list);
        }
        return result;
    }
}
